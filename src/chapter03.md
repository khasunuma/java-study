# 3. クラス

Java アプリケーションは必ず 1 つ以上のクラスから構成されます。たとえ `"Hello, world"` の一文を表示するだけの簡単な処理であっても、それが Java のアプリケーションである限り、必ずいずれかのクラスに属しています。

## 3.1. クラスの基本構造

単に `"Hello, world"` と表示するだけの Java アプリケーションは、以下のクラスで構成されます。クラス名 (`Hello`) とパッケージ名 (`app`) には任意の名前を使用できます。

```java
package app;

public class Hello {
    public static void main(String... args) {
        System.out.println("Hello, world");
    }
}
```

上記のクラスは、`static` メソッド `main` を持ち、その中で Java SE の標準 API である `System.out` クラスの `println` メソッドを呼び出して、`"Hello, world"` という文字列を表示しています。

クラスは、大雑把には以下のような書式で定義することができます。

```
package <パッケージ名>;

[import 文]

[public] [final] class <クラス名> {
    [コンストラクタ (必要なだけ・必要な場所で)]
    [フィールド (必要なだけ・必要な場所で)]
    [メソッド (必要なだけ・必要な場所で)]
}
```

`package` から始まる一行は、デフォルト・パッケージ (無名パッケージ) を使用する場合は不要ですが、デフォルトパッケージの使用は推奨されていないため、ほぼ必須と考えた方が良いでしょう。

クラスは継承することが可能です (クラスを継承する書式は後述します) が、`final` を付加することでそれ以上の継承を禁止することができます。クラスの継承を禁止するケースとして、以下のものがよく挙げられます。

* 初期化時にクラスの状態を設定した後は変更できなくする「イミュータブル」なクラスにする場合。Java SE 標準 API では文字列を表す `String` クラスや日付を表す `LocalDate` クラスなど。
* すべて static メソッドだけで構成されたユーティリティクラスとする場合。Java SE 標準 API では数学関数を集めた `Math` クラスやコレクションを操作する `Collections` クラスなど。

アプリケーションで独自に実装するクラスは継承することがあまりないため、`final` を付加するのが望ましいとする資料もありますが、実際には Java EE 標準 API の一部が内部処理として、アプリケーション独自のクラスをさらに継承するため、`final` を付加すると API が動作しなくなる恐れがあります。現在では、クラスの継承を禁止して大丈夫という確信がない限り、`final` は付加しない方が安全です。

アプリケーションで実装するクラスは `public` から書き始める形で定義しますが、ライブラリの内部実装など特殊なクラスでは `public` を付加しない場合があります。`public` を付加しないクラスは同じパッケージ内のクラスからのみアクセス可能となります。これは次節以降で取り上げるフィールド、メソッド、コンストラクタの「スコープ」と同じものですが、クラスに関しては `public` または省略 (別名をパッケージ・プライベートと言います) の 2 種類のみ選択可能です。

## 3.2. フィールド

フィールドはクラスの状態、すなわちデータ構造を表現するための変数です。フィールドは、`static` フィールドを除き、インスタンスごとに独立した値を保持します。フィールドの定義は、基本的には以下の書式に従います。

```
[スコープ] [static] [final] <データ型> <フィールド名> [ = <初期値>];
```

フィールド名には、慣習としてクラス名と同じくキャメルケースが用いられますが、クラス名の先頭が大文字に対して、フィールド名の先頭は小文字 (例: `fieldValue`) になります。

### 3.2.1. フィールドのスコープとその選び方

スコープは、他のクラスからのアクセス許可について宣言したもので、`public`、`protected`、`private` または省略 (別名をパッケージ・プライベートと言います) のいずれかとなります。スコープの一覧を下表に示します。

|スコープ|アクセス許可の範囲|
|----|----|
|`private`|宣言したクラス内のみ|
|`protected`|宣言したクラスとそのサブクラス|
|`public`|すべてのクラス|
|(省略)|同じパッケージのすべてのクラス|

フィールドの操作は、そのクラスのメソッドからのみ行うのが原則です。この原則に従うと、フィールドのスコープは主に `private` となります。これを「カプセル化」といいます。カプセル化はフィールドに対する不必要なアクセスを制限することでクラスの状態を正常に保つことを目的としています。

Visual Basic 等にはフィールドに対する読み取り／書き込みを制限する「プロパティ」という言語仕様が備わっていますが、Java の言語仕様にはプロパティは存在しないため、メソッドを用いてフィールドに対する読み取り／書き込みを制限します。Java ではこうしたメソッドをアクセサ・メソッドと呼んでおり、特に読み取りに特化したものを getter メソッド、書き込みに特化したものを setter メソッドとして区別しています。

実際のアプリケーションでは、同じクラスに getter メソッドと setter メソッドがペアで存在していることも多く、これらをペアで記述することをコーディング規約で規定するケースも散見されますが、本質的には誤った考え方です。フィールドには読み取りと書き込みの両方を許可するものと、読み取りのみを許可するものが存在し、読み取りのみ許可であれば getter メソッドのみ用意して書き込みをさせないようにコーディングするのが本来の姿です。

### 3.2.2. static および final 宣言子

`static` を付加した場合は、そのフィールドは `static` フィールドとして宣言されます。`static` フィールドはインスタンスを生成しなくても読み書き可能なため、意図しないタイミングで値を設定された場合など、バグの温床になりかねません。通常は `final` と組み合わせて読み取り専用扱いとします。

`final` を付加した場合は、設定した初期値を変更できません。初期値は上記の例のようにインラインで指定するか、後述のコンストラクタによる初期化時に設定することになります。`final` を付加したにもかかわらずいずれの方法でも初期値を指定しなかった場合は、コンパイルエラーとなり実行できません。

`static` と `final` の組み合わせに `public` スコープを加えると、すべてのクラスから参照可能となる定数のようなフィールドが実現できます。以降、便宜上「(public な) 定数フィールド」と呼ぶことにします。

(例) 定数フィールドの宣言 (Java SE 標準 API より、`BigDecimal` クラスの `ROUND_UP` 定数)

```java
public static final int ROUND_UP = 0;  // インスタンスを生成しなくてもアクセス可能 & 変更不可 (定数フィールド)
```

定数フィールド名には、上記のようにすべて大文字のスネークケースが使用されることもあります。これは C の名前付き定数が大文字のスネークケースで命名されていた慣習を踏襲したものです。Java 標準の API に含まれる定数フィールドのうち初期から存在するものは C 風の命名で統一していましたが、現在ではスネークケースによる命名も混在するようになってきています。このあたりの事情は API 開発者のポリシーにも左右されるため、杓子定規に決めつけない方が無難です。

イミュータブルなクラスでは、フィールドはすべて `final` が付加されています。複雑なデータ構造を持つイミュータブルなクラスでは、コンストラクタによるフィールドの初期化が煩雑になるため、「Builder パターン」というテクニックを利用してインスタンスを生成するケースが増えています。Java SE 標準 API におけるもっとも原始的な Builder パターンの例が、`StringBuilder` クラスによる文字列の連結と生成です。

>【バージョン】 `StringBuilder` クラスは Java SE 5.0 で新たに追加された API で、それ以前から存在する `StringBuffer` クラスを代替するものです。

## 3.3. メソッド

メソッドは、クラスの状態に対する操作を表します。メソッドは、`static` メソッドを除き、インスタンスのフィールドやメソッドに対して作用します。メソッドの定義は、基本的には以下の書式に従います。

```
[スコープ] [static] [final] <戻り値の型> <メソッド名>([仮引数のリスト]) {
    [文 (必要なだけ・必要な場所で)]
}
```

メソッド名もフィールド名と同じく、先頭を小文字としたキャメルケースとする慣習があります。Java ではフィールドやメソッドといったクラスのメンバーの名前を、先頭を小文字とするキャメルケースで統一する傾向にあります。クラスのメンバーであっても先頭大文字のキャメルケースを使用する慣習を持つ C# や Visual Basic との文化の違いです。

### 3.3.1. メソッドのスコープとその選び方

スコープは、フィールド同様に他のクラスからのアクセス許可について宣言したもので、`public`、`protected`、`private` または省略 (別名をパッケージ・プライベートと言います) のいずれかとなります。スコープの一覧についてはフィールドの節で示した表を参照してください。

フィールドのスコープは基本的に `private` とすることが多いのですが、メソッドの場合は継承との兼ね合いもありすべてのスコープを使います。まず、メソッドで多用するスコープは `public` と `private` です。

`public` メソッドはすべてのクラスから呼び出されることから、クラス間でのデータの受け渡しや処理を受け持ちます。また、安易な変更は他のクラスやメソッドに悪影響を及ぼす (最悪コンパイルエラーを引き起こす) ため、明確に仕様を決め、周知しておくことが重要です。

>クラスやメソッドの仕様を周知するツールとして、Java にはドキュメンテーション・コメント (別名 Javadoc コメント) が用意されています。ソースコードのクラスやメソッドの宣言部分にコメント形式で仕様を記述し、`javadoc` ツールでドキュメントを仕様書を自動生成する仕組みです。

`private` メソッドは宣言したクラス内でのみ呼び出し可能であるため、他のクラスには仕様を公開しない内部処理の記述に用いられます。複数の `public` メソッドが内部で使用する共通処理 (チェック処理などに多い) や、`public` メソッドの処理が長くなる時の処理分割 (処理を複数の `private` メソッドに分割して、それらを `public` メソッドが呼び出す) が主な用途として挙げられます。

クラスを継承する際に重要になってくるのが `protected` スコープです。

`protected` メソッドは宣言したクラスとそのサブクラスでのみ呼び出し可能です。言い換えると、継承関係にあるクラス間では `public` のように振る舞い、そうでないクラス間では `private` のように振る舞います。

実のところ、`protected` メソッドをそのまま利用するケースはあまりみられません。そのようにしなければならないメリットがほとんどないためです。
`protected` メソッドの効果は、サブクラスでのオーバーライド時に発揮されます。その代表例が Eclipse のプラグイン API 設計です。Eclipse プラグイン API は拡張ポイントを原則として `protected` メソッドとしており、`protected` メソッドのオーバーライドによって元のプラグインを拡張するように設計されています。`public` メソッドを拡張ポイントとしているライブラリやフレームワークも多く見られますが、`public` メソッドのオーバーライドはすべてのクラスに影響が及ぶため、仕様を崩さないよう慎重に行わなければなりません。`protected` メソッドは影響範囲がサブクラスまでに限定されるため、`public` メソッドよりもオーバーライドしやすいと言えます。

パッケージ・プライベートなスコープは、主にライブラリやフレームワークを開発する際に利用されます。ライブラリやフレームワーク全体で利用するがアプリケーションからは呼び出して欲しくない内部実装のメソッドについて、パッケージ・プライベートを選択する場合があります。

フィールドの節ではパッケージ・プライベートなフィールドについて触れませんでしたが、カプセル化の概念からパッケージ・プライベートなフィールドの存在は無意味です (かわりにアクセサ・メソッドをパッケージ・プライベートにすべき)。

パッケージ・プライベートは前述の通りライブラリやフレームワークの開発が主な目的であるため、アプリケーションでの利用は好ましくありません。

### 3.3.2. 引数と戻り値

メソッドには入力にあたる「引数」と、出力に当たる「戻り値」があります。引数はパラメータと呼ばれることもあります (他の言語における呼び名が Java でも定着した事例です)。Java のメソッドでは任意の個数 (0 個以上) の引数と、0 個または 1 個の戻り値を持ちます。引数はさらに、メソッド定義で仮置きする「仮引数」と、メソッド呼び出し側で設定する値である「実引数」とに分類できます。

>他の言語、例えば PL/SQL では 2 個以上の戻り値や、引数と戻り値を兼ねたものなどを宣言できます。

仮引数は複数宣言できるため、それぞれを `,` (カンマ) で区切り、仮引数のリストとします。また、データ型と引数名をペアにして記述します。仮引数のリストは `int year, int month, int day` のようになり、これをメソッド名に続く `( )` 内に記述します。引数を持たないメソッドについては、( ) の中に何も書きません。ただし ( ) 自体を省略することもできません。

>他の言語、例えば C では `( )` に何も書かないと引数が不定の意味になります。また、Visual Basic は引数が存在しない場合に `( )` を省略できますが、Java は省略不可なので注意が必要です。

戻り値には名前がなく、データ型 (戻り値の型) のみを指定します。戻り値を持たない場合はデータ型を void とします。

Java では仮引数のリスト (のデータ型) が異なる同じ名前のメソッドを複数定義することができます。これをメソッドの「オーバーロード」といいます。なお、仮引数のリストは同じで戻り値の型が異なる同じ名前のメソッドは定義することができないため注意してください。メソッドのオーバーロードは、操作の意味合いは同じだが引数のパターンが異なるものを同じメソッド名でまとめるために使用します。言語仕様上は仮引数のリスト (のデータ型) が異なればメソッドのオーバーロードは可能ですが、操作の意味合いを無視してオーバーロードを濫用すると、可読性を大幅に低下させることになりますので、現に慎んでください。メソッドのオーバーロードは主にライブラリ向けの機能であり、アプリケーションで定義する機会はあまりありませんが、アプリケーションからライブラリのオーバーロード・メソッドを呼び出す機会は多いため、理解しておきたい機能です。

(例) メソッドのオーバーライドが許される場合

```java
public void doProcess(int value);
public void doProcess(int value1, int value2);  // OK : 仮引数のリスト (のデータ型) が異なる、仮引数の個数を変えている
public void doProcess(double value);  // OK : 仮引数のリスト (のデータ型) が異なる、仮引数のデータ型を変えている
```

(例) メソッドのオーバーライドが許されない場合

```java
public void doProcess(int value);
public void doProcess(int i);  // NG : 仮引数のリスト (のデータ型) が同じ、仮引数名だけ変えてもダメ
public int doProcess(int value);  // NG : 仮引数のリスト (のデータ型) が同じ、戻り値の型が異なるだけではダメ
```

### 3.3.3. static および final 宣言子

`static` を付加した場合は、そのメソッドは `static` メソッドとして宣言されます。`static` メソッドはインスタンスを生成しなくても実行可能ですが、代わりにインスタンスのメソッドやフィールドに直接触れることもできないため、その用途は比較的限られます。

`static` メソッドの主な用途は「Factory Method パターン」というテクニックを用いたインスタンス生成メソッド (ファクトリ・メソッド) を用意する場合です。実装の複雑なクラスでは後述のコンストラクタだけでは初期化処理が煩雑になる (場合によっては完結しない) ため、`static` メソッドに一連の初期化処理を閉じ込めるテクニックが多用されます。具体的には、インスタンスを生成せずに実行可能な `static` メソッドを用いて、インスタンスの生成と追加の処理 (メソッド呼び出し) を行います。

(例) ファクトリ・メソッドの例 (Java SE 標準 API より、`LocalDate` クラス)

```java
public static LocalDate of(int year, int month, int day) {  // ファクトリ・メソッド; インスタンスを生成しなくてもアクセス可能
    // ここで LocalDate のインスタンスを生成する
    // インスタンス生成後に private メソッド呼び出しによる追加の処理が可能
}

public static LocalDate ofYearDay(int year, int dayOfYear) {  // ファクトリ・メソッド (異なる書式)
    // ここで LocalDate のインスタンスを生成する
    // ファクトリ・メソッドはコンストラクタと異なり名前の制約を受けず、必要なだけ定義可能
    // 実際、LocalDate をはじめ java.time パッケージの API はファクトリ・メソッドを豊富に用意している
}
```

`final` を付加した場合は、サブクラスでメソッドをオーバーライドできなくなります。アプリケーションのクラスは継承することが少ないため、メソッドも積極的に `final` を付加するべきとする資料もあります。ただしクラスの `final` と同様、実際には Java EE 標準 API の一部が内部処理として、アプリケーション独自のクラスをさらに継承し、オーバーライドしたメソッドの中から元のメソッドを呼び出すようなコードを自動生成する場合があります。

>Java EE の CDI でインターセプター (共通化された前処理・後処理) を使用するとほぼ確実にそのような内部処理が行われます。

そのため、クラスの継承を行わない、あるいは継承してもメソッドのオーバーライドを禁止して大丈夫という確信がない限り、`final` は付加しない方が安全です。なお、クラス自体に `final` を付加した場合はクラスの継承自体が禁止されますので、各メソッドへの `final` 付加は意味をなさなくなります。

### 3.3.4. main メソッド

Java アプリケーションのエントリポイントは、任意のクラスに定義された `main` メソッドです。`main` メソッドの書式は Java の言語仕様であらかじめ決められていて、下記のようになります。

```java
public static void main(String[] args) {
    ...
}
```

`String[] args` にはアプリケーション実行時のコマンドライン引数が格納されます。これには別解があり、引数のリストの宣言 `String[] args` を `String... args` に置き換えることもできます。`String... args` の方が新しい書式で、意味的にもコマンドライン引数の姿に近いために好まれる書き方でもあるのですが、コンパイルするといるれの書式でも `String[] args` に変換されてしまうため、最終的には好みの問題になります。

>【バージョン】 `String... args` という書き方は、Java SE 5.0 以降で使用可能な「可変長引数」を用いた書き方です。

アプリケーションの複数のクラスが `main` メソッドを持つ場合、そのアプリケーションには複数のエントリポイントが定義されていることになります。アプリケーションのエントリポイントは 1 つに集約するように設計することが多いため、複数のクラスが `main` メソッドを持っているアプリケーションは設計に違反したコーディングがなされている可能性があります。ただし、設計段階で意図的に複数のエントリポイントを持たせているケースも皆無ではないため、設計を再確認した方が良いでしょう。

>例えば、アプリケーション・サーバ―の GlassFish には、`main` メソッドを持つクラスが複数存在しています。GlassFish は複数の起動方法 (通常、コア部分のみ、他環境からの呼び出し等) を持つため、それぞれに対応した `main` メソッドがあります。

複数のクラスで `main` メソッドを定義できることを応用して、各クラスに `main` メソッドを用意して、そこに単体テストコードを記述することもできます。この方法には実行するコードと単体テストコードを同じクラスにまとめることができるというメリットがあります。ただし、現在では JUnit や TestNG といった単体テストを専門に行うフレームワークが普及しているため、`main` メソッドに単体テストコードを記述することはほとんどなくなっています。

## 3.4. コンストラクタ

コンストラクタはクラスのインスタンスを初期化する際に呼び出される特別な処理です。コンストラクタの定義はメソッドに似ており、基本的には以下の書式に従います。

```
[スコープ] <クラス名>([仮引数のリスト]) {
    [他のコンストラクタ呼び出し]
    [文 (必要なだけ・必要な場所で)]
}
```

コンストラクタの名前はクラス名そのものです。スコープや仮引数のリストはメソッドと同様で、オーバーロードが可能な点もメソッドと共通しています。ただし、メソッドと異なり戻り値を持つことはありません。

### 3.4.1. デフォルト・コンストラクタ

クラスの定義において、コンストラクタは省略することができます。その場合は、暗黙の裡に以下のようなコンストラクタが生成されます。これをデフォルト・コンストラクタといいます。コンストラクタが 1 つでも明示的に定義されている場合には、デフォルト・コンストラクタは生成されません。

```java
public <クラス名>() {

}
```

クラスを継承する際には、スーパークラスが以下のいずれかの条件を満たす場合に限り、サブクラスのコンストラクタを省略することができます (デフォルト・コンストラクタが生成されます)。

* スーパークラスでコンストラクタが定義されていない (デフォルト・コンストラクタが生成される)。
* スーパークラスで継承可能なスコープ (`public` または `protected`、同一パッケージの場合はパッケージ・プライベートも可) の引数なしコンストラクタが定義されている。

### 3.4.2. コンストラクタ内の処理について

コンストラクタ内では、まず始めにクラス内、またはスーパークラスのいずれかのコンストラクタを呼び出さなければなりません。ただし、前節に示したサブクラスのコンストラクタを省略できる条件を満たす場合のみ、スーパークラスのコンストラクタの呼び出しを省略することができます。

コンストラクタ呼び出し後の処理は概ねメソッドと変わりませんが、異なる点として `final` が付加されたフィールドの値が初期化可能です (フィールド宣言時に初期化されている場合を除く)。コンストラクタの処理でメソッドを呼び出すこともできますが、コンストラクタ実行中はインスタンスがまだ生成途中であることから、回避した方が賢明でしょう。
