# 7. 配列とコレクション

# 7.1. 配列

配列は、同じデータ型の変数をメモリ上の連続した領域に確保したものです。配列は通常、1 つの変数に格納できないような大きなデータ (例: ファイル、ネットワークの送受信データ) を保持するために用います。配列を構成する一つひとつの変数を「要素」といい、それぞれの要素には先頭から「添字 (インデックス)」と呼ばれる連番が振られています。

1. `<データ型>[] <配列名>;`
2. `<データ型>[] <配列名> = {[初期値のリスト]};`
3. `<データ型>[] <配列名> = new <データ型>[<要素数>];`


# 7.2. コレクション

# 7.2.1. コレクションと総称型

* `Collection` : コレクションのスーパーインタフェース
  * `List` : 順序を持ち要素の重複を許し、ランダムアクセス可能なコレクション
  * `Set` : 順序を持たず要素の重複を許さない、ランダムアクセス不可能なコレクション
  * `Deque` : 順序を持ち要素の重複を許すが、ランダムアクセス不可能なコレクション
* `Map` : キーと値のペアの集合

コレクションは、どのクラスのインスタンスを格納するのかを「型パラメータ」で指定します。

型パラメータに指定できるのはクラスだけであるため、プリミティブ型を格納したい場合には対応するラッパークラスを型パラメータとして指定します。ただし、要素の追加、変更、取得にはプリミティブ型を直接使用することができます (Java SE 5.0 以降、オートボクシング機能が適用されるため)。


# 7.2.2. コレクションの実装と選び方

# 7.2.3. Collection の主なメソッド

# 7.2.4. イテレータと拡張 for 文

コレクションは必ずしもランダムアクセスが可能とは限りません。例えば `List` は配列同様のランダムアクセスを提供しますが、`Set` と `Deque` ではランダムアクセスを提供していません。コレクションではランダムアクセスの可否に関わらず先頭から要素を取得するための「イテレータ―」と呼ばれるものを提供しています。イテレータによるアクセスを順次アクセス (シーケンシャルアクセス) と呼びます。

```
Set<String> set = new HashSet<>();
...
Iterator iter = set.iterator();
while (iter.hasNext()) {
    String s = iterator.next();
    ...
}
```

拡張 for 文はコレクションまたは配列の要素を先頭から順次取り出すための特殊な繰り返しです。Visual Basic の For-Each-Next 構文、JavaScript の foreach 文に相当します。

```
for (変数 : コレクションまたは配列) 文
```

拡張 for 文は、コレクション (または配列) の読み取りに特化した文です。拡張 for 文の処理中にコレクションの要素を追加/削除することはできません。これはイテレータの使用時にコレクションの要素を追加/削除できないことと同様です。

# 7.2.5. List、Set、Deque の主なメソッド

# 7.2.6. Map の主なメソッド

# 7.3. Arrays クラスと Collections クラス

# 7.3.1. Arrays クラス

# 7.3.2. Collections クラス

# 7.4. 配列とコレクションの相互変換

# 7.4.1. 配列からコレクションへの変換

`Arrays` クラスの `asList` メソッドで配列を `List` に変換可能です。

`Set` や `Deque` への変換は一旦 `List` に変換してから行います。

# 7.4.2. コレクションから配列への変換

`Collection` インタフェースに `toArray` メソッドが用意されています。

1. `Object toArray()`
2. `T[] toArray(T[] array)`

なお、`Map` を配列に直接変換する方法は用意されていません。キーと値の割り当て方に合わせて独自に実装する必要があります。
