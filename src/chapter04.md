# 4. 文

文は Java における処理の最小単位です。主に C++ からアイデアを得ており、C、JavaScript、Python、Visual Basic 等でも採用されている構文が数多く存在します。

## 4.1. 式文

変数、リテラル（文字列・文字・整数・浮動小数点数・論理値）、算術式、論理式、代入式、その他の式、およびこれらの組み合わせのみで構成される文を式文と言います。式文は C と基本的に同一であり、末尾に `;` (セミコロン) を付加します。`;` (セミコロン) を式文の区切りとする JavaScript や、式文の終端記号を持たない Visual Basic とは異なりますので注意してください。

### 4.1.1. 文字列リテラル

前後をダブルクォート `" "` で囲んだ文字の列を文字列リテラル (定数) と呼びます。文字列リテラルは必ず `String` クラスのインスタンスになります。文字列リテラル内では " と \ を直接使用することはできず、それぞれ `\"` と `\\` に置き換えます。文字列リテラルには `\n` : 改行、`\t` : タブ などの制御文字を含めることもできます (制御文字は必ず `\` で始まります)。文字列リテラルの書式は C と同一であり、JavaScript や Visual Basic とは差異があります。

>JavaScript と Python では文字列リテラルを表すのにシングルクォート `' '` を用いることもできますが、Java では次節で取り上げる文字リテラルの構文となるため使用できません。また、Visual Basic では文字列リテラル内で `\` を使用可能だが制御文字が使用できない (`vbCrLf` 等を用いる)、" は `""` で表現するといった違いがあります。
         
文字列 (リテラルを含む) を `+` で繋ぐと、文字列を連結することができます。連結後の文字列は文字列リテラルとなり、`String` クラスのインスタンスとなります。

(例) `"Good night, " + "everybody" + "!"` → `"Good night, everybody!"`

### 4.1.2. 文字リテラル

前後をシングルクォート `' '` で囲んだ文字を文字リテラルと呼びます。文字リテラルはプリミティブ型の `char` 型になります。文字リテラルは 1 文字 (Unicode) または制御文字のいずれかです (制御文字については前節を参照のこと)。文字リテラルの書式は C に類似します (C には ASCII 文字は `char` 型、 Unicode 文字は `wchar_t` 型という区別があります)。文字リテラルは JavaScript および Python には存在しませんが、Visual Basic には存在します。ただし Visual Basic の文字リテラルは文字列リテラル同様に前後をダブルクォート `" "` で囲みます。

(例) `'A'`, `'漢'`, `'\n'`

### 4.1.3. 整数リテラル

整数リテラルは、10 進数、16 進数、8 進数、2 進数で以下のように表現します。2 進数を除き C、JavaScript および Python の整数リテラルと同一の書式です。Visual Basic では 16 進数の先頭に `&H`、8 進数の先頭に `&O` を付加するため、そこが相違点となります。

* `0`, `10`, `16`  // 10 進数; 0-9、0 以外は 0 から始まらない
* `0x0`, `0xa`, `0x10`  // 16 進数; 0-9,a-f(A-F)、先頭に 0x または 0X を付ける
* `00`, `012`, `020`  // 8 進数; 0-8、先頭に 0 を付ける
* `0b0`, `0b1010`, `0b10000`  // 2 進数; 0 or 1、先頭に 0b または 0B を付ける

数値リテラルは通常プリミティブ型の `int` 型になります。`int` 型のサイズに収まらない数値リテラルは `long` 型にする必要があり、その場合にはリテラルの末尾に `L` を付けます (例: `0L`, `10L`, `16L`)。

>【バージョン】2 進数リテラルは Java SE 7 以降で使用することができます。

#### 4.1.3.1. プリミティブ型

Java にはクラス以外に値を保持するためのデータ型である「プリミティブ型」が備わっています。C の「基本データ型」から拝借した仕様で、単純なデータ処理の高速化を目的に当初から導入されています。また、プリミティブ型と対応し相互変換が可能な「ラッパークラス」が用意されています。

|プリミティブ型|格納できるデータ型|初期値|対応するラッパークラス|
|----|----|----|
|`boolean`|論理型 (`true` or `false`)|`false`|`Boolean`|
|`byte`|符号付き 8 ビット整数型|`(byte) 0`|`Byte`|
|`char`|符号なし 16 ビット整数型 (Unicode)|`(char) 0`|`Character`|
|`short`|符号付き 16 ビット整数型|`(short) 0`|`Short`|
|`int`|32 ビット整数型|`0`|`Integer`|
|`long`|64 ビット整数型|`0L`|`Long`|
|`float`|単精度浮動小数点型|`0F`|`Float`|
|`double`|倍精度浮動小数点型|`0D`|`Double`|

>【バージョン】Java SE 5.0 以降、プリミティブ型とラッパークラスは自動で相互変換が可能となり、変換メソッドを用いなくても算術演算や代入などに用いることができます。これを「オートボクシング機能」と言います (プリミティブ型からラッパークラスへの変換を「ボクシング」、その逆を「アンボクシング」と呼んでいます)。

>【バージョン】Java SE 8 ではラッパークラスに `static` メソッドが大幅に追加され、従来 `Math` クラスを利用していたプリミティブ型の比較・変換の一部を各ラッパークラスで行えるようになりました (後述の Stream API で使うことを想定しての機能追加です)。

### 4.1.4. 浮動小数点数リテラル

数値リテラルのうち小数点 `.` を含むものは浮動小数点リテラルと呼ばれます。小数点以下が 0 の場合でも `.0` を付加することで浮動小数点リテラルになります (例: `0`, `16` は整数リテラル、`0.0`, `16.0` は浮動小数点リテラル)。浮動小数点リテラルは C と同一の仕様であり、JavaScript、Python および Visual Basic も類似した書式となります。

Java には 2 種類の浮動小数点型 `float` (単精度浮動小数点型) と `double` (倍精度浮動小数点型) が用意されており、それぞれ表記が決まっています。

* 末尾に `F` (例: `0.0F`, `1.5F`) => `float` 型
* 末尾に `D` (例: `0.0D`, `1.5D`) => `double` 型
* 末尾なし (例: `0.0`, `1.5`) => `double` 型

#### 4.1.4.1. float 型と double 型のどちらを選択すべきか？

特別な理由がない限り `double` 型を選択してください。

浮動小数点型が `float` 型と `double` 型に分かれているのは歴史的経緯によるものです。現在は `double` 型を用いるのが一般的です。

>1990 年代ごろまでの一般的なコンピュータは CPU に浮動小数点演算用のユニットが含まれていませんでした。そのため、多くの CPU は整数演算用ユニットを利用して浮動小数点演算を行っており、消費リソースは少ないが演算桁数も少ない `float` 型と、演算桁数は十分だが消費リソースも大きい `double` 型を使い分けていました。現在の CPU はすべて浮動小数点演算専用のユニットを内蔵しており、設計の簡略化のため `double` 型の演算のみサポートし、`float` 型の演算は CPU 内部で `double` 型に変換した上で実行しています。従って、データ型変換のロスを考慮すると始めからすべて `double` 型で演算をした方が効率がよいのです。

### 4.1.5. 論理値リテラル

`true` は「真」の論理値リテラル、`false` は「偽」の論理値リテラルで、ともに `boolean` 型となります。C (1999 年改定以降)、JavaScript、Python および Visual Basic にも (書式等が微妙に異なるものの) 論理値リテラルは存在します。

### 4.1.6. 算術式

数値同士について、算術演算 (四則演算) がサポートされています。異なる数値型同士の演算の場合、より大きいデータ型 (int < long < double) に合わせられます。文法は C と同一で、JavaScript、Python および Visual Basic とも多くが共通しています (Visual Basic では一部記法が異なります)。

* (加算) x ＋ y :  `x + y`
* (減算) x － y :  `x - y`
* (乗算) x × y : `x * y`
* (除算) x ÷ y : `x / y`
* (剰余) x mod y : `x % y` (Visual Basic と異なり `MOD` ではない)

また、インクリメント (+1)・デクリメント (-1) 演算が存在します。なお、インクリメント・デクリメント演算は Python と Visual Basic には存在しません。

* インクリメント (前置) : `++x`
* インクリメント (後置) : `x++`
* デクリメント (前置) : `--x`
* デクリメント (後置) : `x--`

前置と後置では式の評価タイミングが異なり、前置は評価前に+1/-1演算が行われ、後置は評価後に+1/-1演算が行われます。

(例) x = 3, y = 2 の時

* `++x * y` の結果は、式の値 = 8、x = 4、y = 2 (計算前に+1)
* `x++ * y` の結果は、式の値 = 6、x = 4、y = 2 (計算後に+1)

### 4.1.7. 論理式

数値同士について比較演算がサポートされています。演算結果は boolean 型になります。

* (未満) x ＜ y : `x < y`
* (以下) x ≦ y : `x <= y`
* (等しい) x ＝ y : `x == y` (Pascal、Ada と異なり `:=` ではない)
* (等しくない) x ≠ y : `x != y` (Pascal、Ada、Visual Basic と異なり `<>` ではない)
* (以上) x ≧ y : `x >= y`
* (より大きい) x ＞ y : `x > y`

比較演算には `&&` (AND)、`||` (OR)、`!` (NOT) を使用することができ、基本的な等式・不等式を表現することができます (Visual Basic では記法が異なり、それぞれ `And`、`Or`、`Not` となります)。

#### 4.1.7.1. 条件演算子 (三項演算子)

`x ? y : z` で論理式 x が真のとき y、偽のとき z を値とする「条件演算子 (三項演算子)」が用意されています。ほとんどの場合 `if (x) y; else z;` と同じですが、式は置けるが文は置けない個所で条件分岐をしたい場合に用いられます。条件演算子 (三項演算子) は C および JavaScript と共通であり、Python にもそれに相当する構文があります。また、Visual Basic では `IIf` 関数が相当します。

条件演算子は使い方次第でソースコードの可読性を向上させる場合も悪化させる場合もあるため、注意が必要です。

### 4.1.8. 変数と代入式

式の値に名前を付けたものを変数と言います。変数名にはフィールド名と同じキャメルケース (先頭小文字) を用いるのが慣習ですが、フィールド名と比較して短い名前が付けられる傾向にあります。

* <変数型> <変数名>;
* <変数型> <変数名> = <初期値>;  // 変数の初期化を伴う場合
* `final` <変数型> <変数名> = <初期値>;  // 変数を初期化し、変更できないようにする場合 (定数)

変数に値を設定する式を代入式と言います。書式は以下の通りです。

* <変数名> = <式>
* <変数型> <変数名> = <式>  // 変数の初期化を伴う場合

変数への代入や初期化には `=` を用います。この記法は C、JavaScript、Python および Visual Basic と同じです。ただし、変数型については言語により記法が異なります (C は Java と同様ですが、Visual Basic では変数名の後に `As <データ型>` を付加します。JavaScript と Python には変数型の宣言がありません)。

式の値が `boolean`、`int`、`long`、`double` などプリミティブ型の場合は、式の値が変数にコピーされます。式の値がクラスのインスタンスの場合は、そのインスタンスへの参照が変数にコピーされます。`final` が付加された変数を除き、代入式は何度でも (その変数自身に対しても) 行うことができます。

>代入式の再適用は、変数に設定された値が刻一刻と変化するような状態を表すために用いられます。変数型が同じだからと言って意味合いが全く異なる値を変数に再設定することは、処理の流れを読みづらくするだけなので避けてください。1970 年代のプログラミング言語 (Fortran 77 など) では変数名に利用できる文字の種類や長さに制限があり、宣言できる変数の個数に限界があったため変数を再利用するような手段も採られていましたが、Java では変数名に制約がないため変数を再利用するメリットが全くありません。

変数はメソッド内の任意の場所で宣言することができ、宣言した箇所以降メソッドの終了まで有効です。メソッドの引数は初期値が呼び出し元メソッドで設定された変数とみなすことができます。変数はメソッドごとに独立しているため、異なるメソッドで同じ変数名を使用することは問題ありません。

#### 4.1.8.1. 変数と型キャスト

例えば `long` 型の変数/リテラルであっても明らかに `int` 型のサイズに収まることがわかっている場合があります。そのような場合には、`long` 型の変数/リテラルを `int` 型に変換して `int` 型変数に代入することができます。これを型キャストと言います。型キャストの書式は C と同様で、Visual Basic では `CStr`、`CInt`、`CLong` 関数などがこれに相当します。JavaScript と Python はデータ型変換について Java とは異なるアプローチを採るため割愛します。

```
long longValue = 10L;  // 明らかに int 型のサイズに収まる
...
int intValue = (int) longValue;  // 型キャスト; (データ型) 変数/リテラル
```

キャストは `( )` 内に変換先のデータ型を記述し、変数/リテラルの前に付加します。この時の `( )` は「キャスト演算子」と呼ばれることがあります。キャスト演算子は四則演算や比較よりも優先順位が高く設定されています。

`byte`、`char`、`short` などの整数型は、`int` 型よりも小さなサイズであるため、これらの型の変数に整数リテラルを代入する場合には必ず型キャストが発生します。その他、整数同士の除算を行い結果を浮動小数点数として取得したい (例: 3 / 2 の結果として 1.5 を得たい) 場合等に、演算に先立って数値を double 型にキャストします。

### 4.1.9. その他の式

new 演算子でクラスのインスタンスを生成した結果 (例: `new BigDecimal(150)`) や、メンバ演算子 `.` でクラスのフィールドやメソッドを参照した結果 (例: `s.toUpperCase()`) も、式として扱われます。

(例) new 演算子によるインスタンスの生成式 (代入式との組み合わせ)
```
// インスタンス生成式: new String("Hello, world") → 結果を変数 s に代入
// "Hello, world" は String クラスのコンストラクタの「実引数」(→呼び出しにより仮引数に設定される)
String s = new String("Hello, world");
```

(例) `.` 演算子によるメソッド参照式 (代入式との組み合わせ)
```
// s は String クラスのインスタンスで 5 文字以上と仮定 (具体的には上記の例の結果)
// メソッド参照式: s.subSequence(0, 5) → 結果を prefix に代入
// 0, 5 は subSequence() メソッドの「実引数」(→呼び出しにより仮引数に設定される)
String prefix = s.subSequence(0, 5);
```

### 4.1.10. Java の演算子の優先順位

|順位|演算子|
|----|----|
|1|括弧 `( )`、new 演算子 (`new`)、メンバ演算子 (`.`)、配列演算子 (`[]`)|
|2|単項演算子 (後置); インクリメント (後置)/デクリメント (後置)
|3|単項演算子 (前置); インクリメント (前置)/デクリメント (前置)、ビット反転 (`~`)、NOT (`!`)、符号 (`+`、`-`)、キャスト (`( )`)|
|4|乗除演算子; 乗算 (`*`)、除算 (`/`)、剰余 (`%`)
|5|加減演算子; 加算 (`+`)、減算 (`-`)
|6|シフト演算子; 左シフト (`<<`)、右シフト (`>>` `>>>`)
|7|関係演算子; 未満 (`<`)、以下(`<=`)、以上 (`=>`)、より大きい (`>`)、クラス比較 (`instanceof`)
|8|等価演算子; 等しい (`==`)、等しくない (`!=`)
|9|論理演算子; AND (`&`)、OR (`|`)、XOR (`^`)
|10|AND 演算子 (`&&`)
|11|OR 演算子 (`||`)
|12|条件演算子 (三項演算子); `? :`
|13|代入演算子 (`=`)、複合代入演算子 (`*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `>>>=` `&=` `^=` `|=`)

