# 6. インタフェース

## 6.1. インタフェース

```
public interface Runnable {
    void run();
}
```

```
[public] interface <インタフェース名> [extends <スーパーインタフェース名>] {
    [static フィールド (必要なだけ・必要な場所で)]
    [static メソッド (必要なだけ・必要な場所で)]
    [抽象メソッド (必要なだけ・必要な場所で)]
}
```

インタフェースはインスタンスに対する操作 (メソッド) を宣言するだけで、それ自体のインスタンスを生成できない点では抽象クラスと共通していますが、以下の点が異なります。

* 通常のフィールド、メソッドを定義できない。ただし、`static` フィールド、`static` メソッドについては定義できる (`static` メソッドは Java SE 8 以降)。
* コンストラクタを定義できない (デフォルト・コンストラクタは存在するが、あまり意味を持たない)。
* すべての抽象メソッド、`static` フィールド、`static` メソッドは `public` スコープとなる。
* 複数のスーパーインタフェースを継承できる。
* 抽象メソッドのデフォルト実装を持つことができる (Java SE 8 以降; デフォルト実装には言語使用上の制約があるため注意すること)。

インタフェースは、クラスで「実装」することにより初めて利用することができます。以下にインタフェースを実装するクラスの一般的な書式を示します。インタフェースを実装するクラスは同時にクラスの継承を行っても良く、また抽象クラスとして定義することも可能です。なお、抽象クラスとして定義した場合は、具象クラスであるサブクラスでインスタンスを生成する必要があります。

```
[public] [abstract|final] class <クラス名> [extends <スーパークラス名>] implements <インタフェース名> {
    ...
}
```

例えば、`String` クラスは以下に示すように `Serializable`、`Comparable`、`CharSequence` の 3 つのインタフェースを同時に実装しており、各インタフェースのメソッドからの操作が可能です。

```
public final class String implements Serializable, Comparable<String>, CharSequence {
    ...
}
```

`Comparable` インタフェースは `comapareTo` メソッドによる比較をサポートします。また、`CharSequence` インタフェースは `StringBuilder` 等と共通する基本的な文字列操作メソッドを提供します。

`Serializable` インタフェースは、クラスが直列化可能 (インスタンスをネットワーク越しに利用するための一時保存・復元に対応している) であることを示すもので、以下のように中身のないインタフェースとして定義されます。

```
public interface Serializable {
}
```

`Serializable` インタフェースのように、中身を持たず目印として使用されるインタフェースを「マーカー・インタフェース」と呼びます。現在の Java ではマーカー・インタフェースの代わりにアノテーションを使用する傾向にあります。

インタフェースは Java でポリモーフィズムを実現するための重要な機能であると同時に、後述のラムダ式とも密接な関連があるため、ぜひ使い方を身に着けてください。

## インタフェースと匿名クラス

インタフェースを用いてメソッド内でクラスの実装を行う「匿名クラス」という構文があります。以下に匿名クラスによるインスタンス生成を行って、それを別スレッドで非同期実行する例を示します。

```
public void runAfter() {
    ...
    // 匿名クラスによるインスタンス生成
    Runnable runnable = new Runnable() {
        public void run() {
            ...
        }
    }

    // runnable を別スレッドで非同期実行する
    CompletableFuture.runAsync(runnable);
}
```

一般に、匿名クラスは以下の書式で使用します。

```
[<インタフェース名> <変数名> = ]new <インタフェース名>() {
    [メソッド (すべての抽象メソッドを実装する)]
}
```

上記の例はメソッド本文で匿名クラスを使用しましたが、以下のように呼び出すメソッドの引数でも匿名クラスを使用することができます。

```
public void runAfter() {
    ...
    // Runnable の匿名クラスでインスタンスを生成し、別スレッドで非同期実行する
    CompletableFuture.runAsync(new Runnable() {
        public void run() {
            ...
        }
    });
}

匿名クラスを使用したインスタンス生成はインタフェースだけでなく抽象メソッドでも行うことができます。詳細については割愛しますが、抽象メソッドから匿名クラスを作成する場合は抽象クラスの実装は必須ですが、必要に応じて既存のメソッドのオーバーライドも可能になります。

匿名クラスは直感的ではありませんが、しかるべき必要性があることから用意されています。

Java のメソッドでは引数にデータ (変数・フィールドの値) のみ設定可能で、処理を渡すことができません。しかし、メソッド側では処理の入出力だけを決めておき、実際の処理はメソッドの外部で定義したいケースがあります。代表例がフォルダ階層をスキャンしながら行う処理で、フォルダのスキャン手順はあらかじめ決めておくことができますが、スキャンとともに行う処理までは決められません。このような問題に対処するテクニックである「Visitor パターン」でよく利用されるものが匿名クラスです。「Visitor パターン」で処理を定義するクラスは小規模なものが多く、都度インタフェースまたは抽象クラスから具象クラスを作成していては手間がかかってしまうことから、匿名クラスが多用されています。

>この考え方をさらに推し進めたのが後述するラムダ式です。

匿名クラスでは、外側の変数やフィールドを参照することができますが、それらには `final` が付加されている必要があります。
