# 2. クラス

Java アプリケーションは必ず 1 つ以上のクラスから構成されます。
たとえ "Hello, world" の一文を表示するだけの簡単な処理であっても、
それが Java のアプリケーションである限り、必ずいずれかのクラスに属しています。

## 2.1. クラスの基本構造

単に "Hello, world" と表示するだけの Java アプリケーションは、以下のクラスで構成されます。
クラス名 (Hello) とパッケージ名 (app) には任意の名前を使用できます。

```
package app;

public class Hello {
    public static void main(String... args) {
        System.out.println("Hello, world");
    }
}
```

上記のクラスは、static メソッド main を持ち、その中で Java SE の標準 API である System.out クラスの 
println クラスを呼び出して、"Hello, world" という文字列を表示しています。

クラスは、大雑把には以下のような書式で定義することができます。

```
package <パッケージ名>;

[import 文]

public [final] class <クラス名> {
    [コンストラクタ (必要なだけ・必要な場所で)]
    [フィールド (必要なだけ・必要な場所で)]
    [メソッド (必要なだけ・必要な場所で)]
}
```

package から始まる一行は、デフォルト・パッケージ (無名パッケージ) を使用する場合は不要ですが、
デフォルトパッケージの使用は推奨されていないため、ほぼ必須と考えた方が良いでしょう。

クラスは継承することが可能です (クラスを継承する書式は後述します) が、
final を付加することでそれ以上の継承を禁止することができます。
クラスの継承を禁止するケースとして、以下のものがよく挙げられます。

* 初期化時にクラスの状態を設定した後は変更できなくする「イミュータブル」なクラスにする場合。
Java SE 標準 API では文字列を表す String クラスや日付を表す LocalDate クラスなど。
* すべて static メソッドだけで構成されたユーティリティクラスとする場合。
Java SE 標準 API では数学関数を集めた Math クラスやコレクションを操作する Collections クラスなど。

アプリケーションで独自に実装するクラスは継承することがあまりないため、final を付加するのが望ましいとする資料もありますが、
実際には Java EE 標準 API の一部が内部処理として、アプリケーション独自のクラスをさらに継承するため、
final を付加すると API が動作しなくなる恐れがあります。
現在では、クラスの継承を禁止して大丈夫という確信がない限り、final は付加しない方が安全です。

## 2.2. フィールド

フィールドはクラスの状態、すなわちデータ構造を表現するための変数です。
フィールドは、static フィールドを除き、インスタンスごとに独立した値を保持します。
フィールドの定義は、基本的には以下の書式に従います。

```
[スコープ] [static] [final] <データ型> <フィールド名> [ = <初期値>];
```

スコープは、他のクラスからのアクセス許可について宣言したもので、public、protected、private または省略 (別名をパッケージ・プライベートと言います) 
のいずれかとなります。

|スコープ|アクセス許可の範囲|
|----|----|
|private|宣言したクラス内のみ|
|protected|宣言したクラスとそのサブクラス|
|public|すべてのクラス|
|(省略)|同じパッケージのすべてのクラス|

フィールドの操作は、そのクラスのメソッドからのみ行うのが原則です。
この原則に従うと、フィールドのスコープは主に private となります。これを「カプセル化」といいます。
カプセル化はフィールドに対する不必要なアクセスを制限することでクラスの状態を正常に保つことを目的としています。

C# などの言語にはフィールドに対する読み取り／書き込みを制限する「プロパティ」という言語仕様が備わっていますが、
Java の言語仕様にはプロパティは存在しないため、メソッドを用いてフィールドに対する読み取り／書き込みを制限します。
Java ではこうしたメソッドをアクセサ・メソッドと呼んでおり、特に読み取りに特化したものを getter メソッド、
書き込みに特化したものを setter メソッドとして区別しています。

実際のアプリケーションでは、同じクラスに getter メソッドと setter メソッドがペアで存在していることも多く、
これらをペアで記述することをコーディング規約で規定するケースも散見されますが、本質的には誤った考え方です。
フィールドには読み取りと書き込みの両方を許可するものと、読み取りのみを許可するものが存在し、
読み取りのみ許可であれば getter メソッドのみ用意して書き込みをさせないようにコーディングするのが本来の姿です。

static を付加した場合は、そのフィールドは static フィールドとして宣言されます。
static フィールドはインスタンスを生成しなくても読み書き可能なため、意図しないタイミングで値を設定された場合など、
バグの温床になりかねません。通常は final と組み合わせて読み取り専用扱いとします。

final を付加した場合は、設定した初期値を変更できません。初期値は上記の例のようにインラインで指定するか、
後述のコンストラクタによる初期化時に設定することになります。
final を付加したにもかかわらずいずれの方法でも初期値を指定しなかった場合は、コンパイルエラーとなり実行できません。

static と final の組み合わせに public スコープを加えると、すべてのクラスから参照可能な定数のようなフィールドが実現できます。

(例)
```
public static final int ROUND_UP = 0;  // インスタンスを生成しなくてもアクセス可能 & 変更不可 (定数)
```

イミュータブルなクラスでは、フィールドはすべて final が付加されています。
複雑なデータ構造を持つイミュータブルなクラスでは、コンストラクタによるフィールドの初期化が煩雑になるため、
「Builder パターン」というテクニックを利用してインスタンスを生成するケースが増えています。

    Java SE 標準 API におけるもっとも原始的な Builder パターンの例が、StringBuilder クラスによる文字列の連結と生成です。


## 2.3. メソッド

メソッドの定義は、基本的には以下の書式に従います。

```
[スコープ] [static] [final] <戻り値の型> <メソッド名>([<引数の型> <引数名>[, <引数の型> <引数名>...]]) {
    [文 (必要なだけ・必要な場所で)]
}
```

`static` を付加した場合は、すべてのインスタンスから (またはインスタンスを生成しなくても) アクセスできるようになります。

(例)
```
public static Integer valueOf(int i) {  // インスタンスを生成しなくてもアクセス可能
    ...
}
```

`final` を付加した場合は、サブクラスでメソッドをオーバーライドできなくなります (後述)。

## 2.4. コンストラクタ

コンストラクタの定義は、基本的には以下の書式に従います。

```
[スコープ] <クラス名>([<引数の型> <引数名>[, <引数の型> <引数名>...]]) {
    [文 (必要なだけ・必要な場所で)]
}
```
