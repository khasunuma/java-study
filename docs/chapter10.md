# 10. 配列とコレクション

## 10.1. 配列

配列は、同じデータ型の変数をメモリ上の連続した領域に確保したものです。配列は通常、1 つの変数に格納できないような大きなデータ (例: ファイル、ネットワークの送受信データ) を保持するために用います。配列を構成する一つひとつの変数を「要素」といい、それぞれの要素には先頭から「添字 (インデックス)」と呼ばれる連番が振られています。配列の各要素に対して配列全体を「配列オブジェクト」と呼ぶこともあります。

Java における配列は、配列全体としてみた場合はクラスに準じた扱いとなり、フィールドとすることや、メソッド・コンストラクタの引数または戻り値として使用することができます。

### 10.1.1. 配列生成式

配列を生成するための式を「配列生成式」といいます。配列生成式で用いる記号 `[ ]` を配列演算子と呼び、宣言するものが配列であることと、配列の要素数を表します。

- 書式 (1): `new Type [ n ]` (`Type`: 基本データ型、`n`: 要素数)
- 書式 (2): `new Type [] { [ value [, value ...] ] }` (`Type`: 基本データ型、`value`: 初期値)
- 基本データ型 `Type` は配列の各要素のデータ型を表し、具体的にはプリミティブ型またはクラスとなります。基本データ型と配列演算子 `[ ]` が組み合わさることで配列生成式として認識されます。
- 書式 (1) は、配列の要素数を指定して配列を生成する式です。要素数は `[ ]` 内に指定された値となり、各要素の初期状態は変数・フィールドの初期値と同じ扱いとなります。
  - 配列をフィールドの初期値として生成した場合、各要素の初期値はフィールドと同じになります。
  - 配列をメソッド内で生成した場合、各要素の初期値はローカル変数同様「不定」であるため、改めて値を代入する必要があります (配列アクセス式を用います)。
- 書式 (2) は、配列の初期値を指定して配列を生成する式です。`{ }` 内に初期値をカンマ区切りで列挙します (0 個も許されます)。配列の要素数は列挙した初期値の数となります。
  - 配列演算子 `[ ]` の中には値を記述しません。
  - 配列の各要素が初期化される点では確実ですが、初期値の指定に漏れがあると予期しない要素数の配列が生成されるため注意が必要です。

### 10.1.2. 配列変数宣言文

配列はそれ全体を変数として宣言することができます。

- 書式: `Type [ ] array [= expr] ;` (`Type`: 基本データ型、`array`: 配列の変数名、`expr`: 初期値) 
- 基本データ型 `Type` は配列の各要素のデータ型を表し、具体的にはプリミティブ型またはクラスとなります。基本データ型と配列演算子 `[ ]` が組み合わさることで配列の変数宣言文として認識されます。
- 初期値 `expr` は配列生成式または既存の配列となります。`expr` が表す配列の基本データ型は、配列の変数宣言文の基本データ型 `Type` と一致している必要があります。
- 配列の変数宣言文は、ローカル変数宣言文としても、フィールド定義 (初期化を含む) としても使用することができます。

### 10.1.3. 配列アクセス式

配列アクセス式を使用すると、配列の各要素に対して読み取りまたは書き込みができるようになります。

- 書式: `array [ index ]` (`array`: 配列の変数名、`index`: 添字)
- 添字 `index` は `0` から始まり、要素数 - 1 までの間で指定します。添字が負数、または要素数 - 1 を超えた場合には Java VM が非チェック例外 `ArrayIndexOutOfBoundsException` をスローします。
- 変数名と添字の組み合わせにより、基本データ型の変数として扱うことができるようになります。

### 10.1.4. 配列の length フィールド

Java の配列には `length` フィールドが組み込まれており、生成された配列の要素数を取得できるようになっています。

- 書式: `array . length` (`array`: 配列の変数名)
- `array . length` は読み取り専用です。
- `array . length` の値は要素数 (`int` 型) です。このことから、配列の添字には `0` から `array . length - 1` までの範囲の数値 (`int` 型) を使用できることがわかります。
- 初期化していない `array . length` を読み取ろうとすると、Java VM が非チェック例外 `NullPointerException` をスローします。

配列の `length` フィールドは、配列操作時に添字の範囲を超えないようにするため頻繁に参照されます。また、for 文と組み合わせて配列の要素に連続してアクセスするためにも用いられます。特に他のメソッドで生成された配列は要素数がわからないため、必ず `length` フィールドで要素数をチェックするようにしましょう。

```java
byte[] array = new byte[256];

for (int index = 0; index < array.length; index++) {
    array[index] = (byte) 0;
}
```

### 10.1.5. 多次元配列

Java には Visual Basic のような多次元配列をサポートしません。代わりに配列の要素を配列として宣言することで多次元配列のように用いることができます。

多次元配列は数値演算で使用することはありますが、元々使い勝手が悪く、使用頻度も低いためここでは割愛します (実際に多次元配列が必要な局面では、多次元配列の機能を持つクラスを定義して用いることが多いようです)。

## 10.2. コレクション

### 10.2.1. Java Collections Framework とは

Java SE の標準 API には "Java Collections Framework" と呼ばれる、主要なデータ構造と基本的なアルゴリズムをサポートするクラスライブラリが含まれています。他の言語ではプログラマが必要なデータ構造とアルゴリズムを選択して独自に実装しなければならない場合もありますが、Java ではそれらがあらかじめ API として用意されているため、適切なデータ構造とアルゴリズムを選択するだけで済みます。

ここでは、Java Collections Framework で定義されているデータ構造をコレクションと呼びます。コレクション (操作) はインタフェースにて定義されており、それぞれ要素の保持方法などが異なる複数の実装クラスを持っています。実装クラスは通常、標準で用意されているものだけでも十分ですが、必要に応じて独自に定義することもできます。

コレクションとその実装は `java.util` パッケージに集約されています。以下に基本的かつ使用頻度の高いコレクションを示します。

- `Collection` : コレクションのスーパーインタフェース。順序、要素の重複およびアクセス方法はサブインタフェースが決定する。
  - `Set` : 集合。順序を持たず要素の重複も許さない。
  - `List` : リスト。順序を持ち要素の重複も許す、配列同様に添字を用いて要素にアクセスする。
  - `Queue` : キュー。順序を持ち要素の重複も許す、FIFO (先入れ先出し) で要素にアクセスする。
  - `Deque` : 両端キュー。順序を持ち要素の重複も許す、FIFO (先入れ先出し) に加えて LIFO (後入れ先出し) で要素にアクセスする。
- `Map` : テーブル、連装配列とも。キーと値のペアの集合。

>【バージョン】 Java Collections Framework は J2SE 1.2 で追加されました。Java Collections Framework は Java のバージョンアップのたびに改訂されていますが (例えば、`Queue` は Java SE 5.0、`Deque` は Java SE 6 での改訂時に追加されたものです)、基本設計が優秀だったため J2SE 1.2 時代と大きく変わることなく現在に至っています。JDK 1.1 まではコレクションに相当するものとして、リストを表す `Vector` やテーブルを表す `Hashtable` などが存在していました。これらは現在コレクションとの互換性を持つように改修されていますが、古い API のためできるだけ使用しないことが推奨されています。

### 10.2.2. コレクションとジェネリクス (総称型)

コレクションは、どのクラスの要素を設定するものかを示すための「型パラメータ」と呼ばれるものを持ちます。コレクションに限らず、型パラメータを持つクラスのことを「ジェネリクス (総称型)」と呼びます。型パラメータは `< T >` のようにクラス名を `< >` で囲んで表現します。以下に例を挙げます。

- `List<String>` : `String` クラスの要素を格納する `List`
- `Queue<Integer>` : `Integer` クラスの要素を格納する `Queue`
- `Map<String, BigDecimal>` : `String` クラスのキーと `BigDecimal` クラスの値のペアからなる `Map`

型パラメータに指定できるのはクラスのみであるため、コレクションの要素にはプリミティブ型を設定することはできません。そこで、プリミティブ型に対応するラッパークラスを型パラメータに指定した上で (例: `int` 型の `List` の場合は `List<Integer>`)、プリミティブ型とラッパー型の相互変換を行うことになります。ただし、相互変換自体は自動で行われるため (オートボクシング機能)、通常はプリミティブ型のままでコレクションの操作を行って構いません。

>【バージョン】 ジェネリクス (総称型) が導入されたのは Java SE 5.0 以降で、それ以前の古い Java には型パラメータはなく、コレクションの要素は `Object` クラスで固定されていました。古い Java ではコレクションの要素から値を取り出す時にキャストが必須であり、一方でコレクションの要素にはどのようなインスタンスでも設定できてしまうことから (`Object` はすべてのクラスのスーパークラスであるため)、エラー (`ClassCastException`) が多発する原因でした。その反省から、現在の Java ではジェネリクス (総称型) が導入され、指定したクラス以外の要素は設定できないようになっています。

### 10.2.3. コレクションのインスタンス生成式と変数宣言文

コレクションのインスタンス生成式は以下のようになります。

- 書式 (1): `new ClassName < T > ( [ args ] )` (`ClassName`: クラス名、`T`: 型パラメータ、`args`: コンストラクタ引数)
- 書式 (2): `new ClassName <> ( [ args ] )` (`ClassName`: クラス名、`args`: コンストラクタ引数)
- 書式 (1) はコレクションのインスタンス生成式の基本形です。
- 書式 (2) は、適用する型パラメータが明らかである場合の略式表記で、型パラメータを省略して代わりにダイヤモンド演算子 `<>` を記述します。確実に書式 (2) を適用できるケースは、インスタンス生成式を変数宣言文に記述する場合です (左辺式である変数のデータ型が型パラメータを明示するため)。

また、コレクションの変数宣言文は以下のようになります。

- 書式: `ClassName < T > var [ = expr ] ;` (`ClassName`: クラス名、`T`: 型パラメータ、`expr`: インスタンス生成式または既存のコレクション)
- クラス名は、実際にはコレクションを表すインタフェース (`List`、`Set`、`Deque`、`Map` など) を指定する場合がほとんどです。実装クラスを指定するケースは、独自のメソッドを使用したい場合に限られます (実際にはほとんどありません)。

コレクションのインスタンス生成式、変数宣言文、ダイヤモンド演算子の使用例を以下に示します。

```java
// (1) コレクションのインスタンス生成式 (基本形)
// ここでは、List の実装である ArrayList のインスタンスを生成します
// 型パラメータは String とします
List<String> list1 = new ArrayList<String>();

// (2) コレクションのインスタンス生成式 (ダイヤモンド演算子)
// 左辺式のデータ型 List<String> より型パラメータが String であることは明らかのため、
// インスタンス生成式の型パラメータは省略できます。
List<String> list2 = new ArrayList<>();
```

【バージョン】 ダイヤモンド演算子は Java SE 7 で導入された記法です。Java はダイヤモンド演算子から適切な型パラメータを導くために型推論という仕組みを用いていますが、Java SE 7 の型推論は限定的であり、ダイヤモンド演算子を使用できない場面が多くありました。Java SE 8 では 12 章で取り上げるラムダ式を導入するために型推論の全面的見直しが図られた結果、インスタンス生成式が使用できるほとんどの場所でダイヤモンド演算子が適用できるよう改善されています。

### 10.2.4. コレクションの実装と選び方

前節で述べた通り、コレクションにはそれぞれデータの保持方法が異なる複数の実装クラスがあります。保持方法によりアクセス特性に違いがあるため、最適な実装クラスを選択するようにしましょう。

|保持方法|`Set<E>`|`List<E>`|`Deque<E>`|`Map<K, V>`|
|----|--------|--------|---------|--------|
|ハッシュ表|`HashSet`|`--`|`--`|`HashMap`|
|可変配列|`--`|`ArrayList`|`ArrayDeque`|`--`|
|B ツリー|`TreeSet`|`--`|`--`|`TreeMap`|
|連結リスト|`--`|`LinkedList`|`LinkedList`|`--`|
|ハッシュ表 + 連結リスト|`LinkedHashSet`|`--`|`--`|`LinkedHashMap`|

|保持方法|順次アクセス|直接アクセス|挿入・削除|
|--------|--------|--------|--------|
|ハッシュ表|遅い|非常に速い|非常に速い|
|可変配列|速い (サイズに依存)|速い (サイズに依存)|遅い|
|B ツリー|普通|普通|速い (速度一定)|
|連結リスト|速い (サイズに依存)|遅い|速い (サイズに依存)|

コレクションの宣言と実装の選択は、以下の基本方針に従うと良いでしょう。

1. 基本となるデータ型を決める: `String`, `Integer`, `BigDecimal`, etc.
2. データ構造を決める: `Set<E>`, `List<E>`, `Deque<E>`, `Map<K, V>`, etc.
3. データ構造の実装を決める

>【バージョン】 `LinkedHashSet`、`LinkedHashMap` は J2SE 1.4 で、`ArrayDeque` は Java SE 6 でそれぞれ追加されたものです。

#### 10.2.4.1. Stringクラス、順不同、重複なし

1. 基本データ型 → String
2. データ構造 = 順不同、重複なし → Set<String>
3. 実装 = 要件なし → HashSet<String>

(推奨される実装) `Set<String> set = new HashSet<>();`

#### 10.2.4.2. int型、順序あり、直接アクセスあり

1. 基本データ型 → Integer (ラッパー)
2. データ構造 = 順序あり、直接アクセスあり → List<Integer>
3. 実装 = 要件なし → ArrayList<Integer>

(推奨される実装) `List<Integer> list = new ArrayList<>();`

#### 10.2.4.3. Integerクラス、順序あり、直接アクセスあり、挿入・削除が多い

1. 基本データ型 → Integer
2. データ構造 = 順序あり、直接アクセスあり → List<Integer>
3. 実装 = 挿入・削除多い → LinkedList<Integer>

(推奨される実装) `List<Integer> list = new LinkedList<>();`

### 10.2.5. Collection の主なメソッド

`Collection` インタフェースにはいくつものメソッドが定義されていますが、その中からよく使われるものを以下に示します。これらはコレクション (`Map` を除く) で共通して使用できるメソッドであるため、押さえておきましょう。

|メソッド名|説明|
|----------------|----------------|
|`boolean add(E e)`|コレクションに要素を追加する|
|`void clear()`|コレクションの全要素を削除する|
|`boolean contains(Object o)`|要素がコレクションに含まれている場合は `true`、そうでなければ `false` を返す|
|`boolean isEmpty()`|コレクションの要素数が 0 の場合は `true`、そうでなければ `false` を返す|
|`Iterator<E> iterator()`|イテレータを返す (後述)|
|`boolean remove(Object o)`|コレクションの要素を削除する|
|`int size()`|コレクションの要素数を返す|
|`<T> T[] toArray(T[] a)`|コレクションを T 型/クラスの配列に変換する (後述)|

### 10.2.6. イテレータと拡張 for 文

コレクションは、要素にアクセスする標準的な手段として「イテレータ―」と呼ばれる仕組みを提供しています。イテレータとはコレクションの要素を指し示すもので、イテレータを介することによりコレクションの実装に依存しない形で要素にアクセスすることが可能となります。イテレータによるアクセスを順次アクセス (シーケンシャルアクセス) と呼びます。

コレクションのうち使用頻度の高い `List` では、後述のように配列同様に添字を用いてすべての要素にアクセスできるため、イテレータの必要性は感じられないかもしれません。しかし、他のコレクションである `Set` や `Deque` では添字を用いることができません。そのため、コレクションの種類によらず使用可能なイテレータが必要になってきます。

イテレータを持つクラスは、`Iterable` インタフェースを実装する必要があります。`Collection` インタフェースは `Iterable` インタフェースのサブインタフェースであるため、`Collection` から派生したコレクションはすべてイテレータをもっています。

>【バージョン】 `Iterable` インタフェースは後述の拡張 for 文を導入するために Java SE 5.0 で追加されたものです。

イテレータは `Iterator` クラスのインスタンスであり、中心となるメソッドは以下の 3 種類です。

|メソッド|説明|
|--------|------------|
|`hasNext()`|次の要素がある場合は `true`、そうでなければ `false` (要素数が 0 の場合は常に `false`)|
|`next()`|次の要素を取得する|
|`remove()`|現在の要素 (= 前回 `next()` で取得した要素) を削除する|

以下にイテレータの使用例を示します。イテレータの使用時には、以下の点に注意してください。

1. イテレータ取得時 (`Collection . iterator()` 呼び出し直後) はどの要素も指し示していない。
2. 最初の要素を指し示すには `Iterator . next()` メソッドを呼び出す。
3. コレクションに要素がない場合は `Iterator . next()` メソッドの呼び出しが失敗するため、事前に `Iterator . hasNext()` メソッドでチェックする。
4. `Iterator . remove()` メソッドはあまり使われない。イテレータの状態を常に意識する必要があり、処理が煩雑になりがち。

`Set` におけるイテレータの使用例を以下に示します。

```java
Set<String> set = new HashSet<>();
...
Iterator iter = set.iterator();
while (iter.hasNext()) {
    String s = iterator.next();
    ...
}
```

イテレータを利用した繰り返しを簡潔に表現するため、Java には拡張 for 文と呼ばれる特殊な繰り返しがあります。上記のイテレータの使用例を拡張 for 文で書き直したものを以下に示します。

(例) 拡張 for 文の使用例

```java
Set<String> set = new HashSet<>();
...
for (String s : set) {
    ...
}
```

拡張 for 文については 5 章でも取り上げましたが、この章で解説します。拡張 for 文の書式は以下の通りとなります。

- 書式: `for ( T var : expr ) stmt` (`T`: データ型、`var`: ローカル変数名、`expr`: `Iterable` 実装のインスタンスまたは配列)
- `expr` が `T` クラスのイテレータを返す `Iterable` 実装か、または `T` 型の配列の場合に限って使用できます。
- `expr` を評価して取得した要素を `var` に代入し、`stmt` を実行する処理を、`expr` のすべての要素に対して順番に実行します。
- 拡張 for 文が、if-else 文 `if ( expr ) stmt1 else stmt2` の `stmt1` に該当する場合には、`stmt` には if 文以外を指定します。そうでない場合は任意の文を指定できます。

拡張 for 文は、以下のように  while 文 (Iterable の実装クラス) または for 文 (配列) で書き換えることができます。

```java
// expr が Iterable の実装の場合の書き換え (while 文)
Iterator<T> iter = expr.iterator();
while (iter.hasNext()) {
    T var = iter.next();
    stmt
}
```

```java
// expr が配列の場合の書き換え (for 文)
for (int index = 0; index < expr.length; index++) {
    T var = expr[index];
    stmt
}
```

拡張 for 文には以下のようなメリットがあります。

1. コレクション・配列を問わず同じ構文で扱うことができる。
2. 要素の最後を判定する必要がない。
3. 記述がシンプルになる。

一方で、拡張 for 文の使用には以下の条件があります。

1. 繰り返し対象は `Iterable` インタフェースの実装または配列。
2. 繰り返し処理では要素の読み取りのみ可能。要素を追加・変更・削除することはできない。

拡張 for 文は必須の構文ではありませんが、コレクションを操作する上で非常に有益であるため、覚えておいた方が良いでしょう。

### 10.2.7. List、Queue、Deque の主なメソッド

`Set` には独自のメソッドは特に用意されていませんが、`List`、`Queue` および `Deque` には独自のメソッドが用意されています。`List` はリスト操作 (直接アクセス、ランダムアクセス)、`Queue` はキュー操作 (FIFO)、`Deque` はキュー操作 (FIFO) およびスタック操作 (LIFO) を提供します。

#### 10.2.7.1. リスト操作 (list のみ)

http://docs.oracle.com/javase/jp/8/docs/api/java/util/List.html

|メソッド名|説明|
|----------------|----------------|
|`boolean add(int index, E element)`|`index` 番目に要素を挿入する|
|`E get(int index)`|`index` 番目の要素を取得する|
|`int indexOf(Object o)`|要素が最初に見つかった `index` を返す|
|`int lastIndexOf(Object o)`|要素が最後に見つかった `index` を返す|
|`int remove(int index)`|`index` 番目の要素を削除する|
|`E set(int index, E element)`|`index` 番目の要素を置き換える|

#### 10.2.7.2. キュー操作 (Queue および Deque)

http://docs.oracle.com/javase/jp/8/docs/api/java/util/Queue.html

|メソッド名|説明|
|----------------|----------------|
|`boolean add(E e)`|要素をキューへ挿入する|
|`boolean offer(E e)`|要素をキューへ挿入する (失敗した場合は非チェック例外 `NoSuchElementException` をスロー)|
|`E poll()`|要素を取得してキューから取り除く (要素がなければ `null` を返す)|
|`E element()`|要素を取得してキューから取り除く (要素がなければ非チェック例外 `NoSuchElementException` をスロー)|
|`E peek()`|要素を取得するがキューには残す (要素がなければ `null` を返す)|
|`E remove()`|要素を取得するがキューには残す (要素がなければ非チェック例外 `NoSuchElementException` をスロー)|

#### 10.2.7.3. スタック操作 (Deque のみ)

http://docs.oracle.com/javase/jp/8/docs/api/java/util/Deque.html

|メソッド名|説明|
|----------------|----------------|
|`void push(E e)`|要素をスタックへ挿入する|
|`E pop()`|要素を取得してスタックから取り除く|
|`E peek()`|要素を取得するがスタックには残す|

### 10.2.8. Map の主なメソッド

http://docs.oracle.com/javase/jp/8/docs/api/java/util/Map.html

|メソッド名|説明|
|----------------|----------------|
|`void clear()`|すべてのエントリ (キーと値のペア) を削除する|
|`boolean containsKey(Object key)`|キーが含まれている場合は `true`、そうでない場合は `false` を返す|
|`Set<K> keySet()`|すべてのキーを返す (`Set` インタフェース)|
|`V get(Object key)`|キーに対応する値を取得する (存在しない場合は `null` を返す)|
|`V getOrDefault(Object key, V defaultValue)`|キーに対応する値を取得する (存在しない場合は `defaultValue` を返す)|
|`V put(K key, V value)`|キーに対応する値を設定する (既に存在する場合は置き換える)|
|`V putIfAbsent(K key, V value)`|キーに対応する値を設定する (既に存在する場合は置き換えない)|
|`V remove(Object key)`|キーと対応する値を削除する (存在しない場合は何もしない)|
|`int size()`|エントリ (キーと値のペア) の数を返す|
|`Collection<V> values()`|すべての値を返す (`Collection` インタフェース)|

>【バージョン】`getOrDefault()` および `putIfAbsent()` メソッドは Java SE 8 で追加されたものです。`get()` および `put()` メソッドと比較して、不要な `null` チェックを回避できる (すなわち `NullPointerException` がスローされにくい) 点で優れています。この他にも `Map` には Java SE 8 で追加されたメソッドが多数あります。

## 10.3. Arrays クラスと Collections クラス

### 10.3.1. Arrays クラス

http://docs.oracle.com/javase/jp/8/docs/api/java/util/Arrays.html

|メソッド名|説明|
|--------|--------|
|`asList`|指定された配列に連動する固定サイズのリストを返す|
|`binarySearch`|配列から指定された値を検索する (二分検索)|
|`copyOf`|指定された配列をコピーする (長さは必要に応じて切り詰めるかパディング)|
|`copyOfRange`|指定された配列の指定された範囲を新しい配列にコピーする|
|`equals`|2 つの配列が互いに同等である場合に `true` を返す|
|`hashCode`|指定された配列の内容に基づくハッシュ・コードを返す|
|`toString`|指定された配列の文字列表現を返す|
|`deepEquals`|2つの配列が互いに等価な場合に `true` を返す (深層内容)|
|`deepHashCode`|指定された配列のハッシュ・コードを返す (深層内容)|
|`deepToString`|指定された配列の文字列表現を返す (深層内容)|
|`fill`|配列の各要素を設定する (同一の値を使用する)|
|`sort`|指定された配列をソートする|
|`setAll`|配列のすべての要素を設定する (異なる値も設定可)|
|`parallelSort`|指定された配列をソートする (マージソード・並列処理)|
|`parallelSetAll`|配列のすべての要素を設定する (異なる値も設定可・並列処理)|

`equals`、`hashCode`、`toString` はプリミティブ型およびクラスの配列に使用可能で、単純な比較、ハッシュ・コード計算、文字列表現取得を行います。`deepEquals`、`deepHashCode`、`deepToString` はクラスの配列に使用可能で、インスタンスの詳細まで参照して比較、ハッシュ・コード計算、文字列表現取得を行います。一見すると `deep` ～の方が優れているようにも見えますが、どのレベルまで参照すべきかはユースケースにより異なりますので、一概に優劣はつけられません。

`fill` は配列の各要素を同じ値で埋めるために使用します。`setAll`、`parallelSetAll` も配列の各要素を埋める点では同じですが、添字によって異なる値を設定可能である点が異なります。

`sort`、`setAll` は逐次処理で実行されますが、`parallelSort`、`parallelSetAll` は並列処理で実行されます。扱う要素数が多く CPU パワーにも余裕がある場合は並列処理を、扱う要素数が少ないか CPU パワーに余裕がない場合は逐次処理を選択するのが効率的です。通常使用する範囲では逐次処理で問題はありません。

>【バージョン】 Java SE 5.0: `deepEquals`、`deepHashCode`、`deepToString`、Java SE 6: `copyOf`、`copyOfRange`、Java SE 8: `setAll`、`parallelSetAll`、`parallelSort`

### 10.3.2. Collections クラス

http://docs.oracle.com/javase/jp/8/docs/api/java/util/Collections.html

|メソッド名|クラス|説明|
|--------|--------|--------|
|`addAll`|`Collection`|指定されたすべての要素を `Collection` に追加する (高速)|
|`binarySearch`|`List`|リストからインスタンスを検索する (二分探索)|
|`copy`|`List`|あるリストから別のリストにすべての要素をコピーする|
|`disjoint`|`Collection`|2 つの `Collection` に共通の要素がない場合に `true` を返す|
|`emptyIterator`|N/A|空のイテレータを返す|
|`emptyList`|N/A|空の `List` を返す|
|`emptyMap`|N/A|空の `Map` を返す|
|`emptySet`|N/A|空の `Set` を返す|
|`fill`|`List`|すべての要素を指定した要素で置き換える|
|`frequency`|`Collection`|指定されたオブジェクトと等価な要素の数を返す|
|`indexOfSubList`|`List`|サブ・リストが最初に出現した位置の開始位置を返す|
|`lastIndexOfSubList`|`List`|サブ・リストが最後に出現した位置の開始位置を返す|
|`max`|`Collection`|最大の要素を返す|
|`min`|`Collection`|最小の要素を返す|
|`nCopies`|N/A|指定されたインスタンスの n 個のコピーで構成される不変の `List` を返す|
|`replaceAll`|`List`|指定された値をすべて置き換える|
|`reverse`|`List`|リストの要素の順序を逆にする|
|`rotate`|`List`|リストの要素を指定された距離により回転する|
|`shuffle`|`List`|リストの順序をシャッフルする|
|`singleton`|N/A|指定されたインスタンスだけを格納する不変の `Set` を返す|
|`singletonList`|N/A|指定されたインスタンスだけを格納する不変の `List` を返す|
|`singletonMap`|N/A|指定されたインスタンスだけを格納する不変の `Map` を返す|
|`sort`|N/A|リストを昇順ソートする|
|`swap`|`List`|リストの指定された位置にある要素を入れ替える|
|`synchronizedCollection`|`Collection`|スレッドセーフな `Collection` を返す|
|`synchronizedList`|`List`|スレッドセーフな `List` を返す|
|`synchronizedMap`|`Map`|スレッドセーフな `Map` を返す|
|`synchronizedSet`|`Set`|スレッドセーフな `Set` を返す|
|`unmodifiableCollection`|`Collection`|不変な `Collection` を返す|
|`unmodifiableList`|`List`|不変な `List` を返す|
|`unmodifiableMap`|`Map`|不変な `Map` を返す|
|`unmodifiableSet`|`Set`|不変な `Set` を返す|


>【バージョン】 J2SE 1.3: `singletonList`、`singletonMap`、J2SE 1.4: `indexOfSubList`、`lastIndexOfSubList`、`rotate`、Java SE 5.0: `addAll`、`disjoint`、`emptyList`、`emptyMap`、`emptySet`、`frequency`、Java SE 7: `emptyIterator`

### 10.4. 配列とコレクションの相互変換

### 10.4.1. 配列からコレクションへの変換

配列は `Arrays` クラスの `asList` メソッドを用いて `List` に変換可能です。その他のコレクション、例えば `Set` や `Deque` への変換は、一旦 `List` に変換してから行います。

```java
// 変換前の配列
String[] strings = new Strings[] { "Able", "Baker", "Charlie" };

// 配列から List への変換
List<String> stringList = Arrays.asList(strings);

// 配列から Set への変換 (List 経由)
Set<String> stringSet = new HashSet<>(Arrays.asList(strings));

// 配列から Deque への変換 (List 経由)
Deque<String> stringDeque = new ArrayDeque<>(Arrays.asList(strings));
```

`Arrays` クラスの `asList` メソッドは可変長引数となっており、配列だけでなく、任意個のインスタンスからなる `List` を手軽に作成可能です。例えば、以下のようになります。

```java
// Arrays.asList だけで List を作成可能
List<String> stringList = Arrays.asList("Able", "Baker", "Charlie");
```

# 7.4.2. コレクションから配列への変換

`Collection` インタフェースに `toArray` メソッドが用意されています。

- `Object[] toArray()`
- `T[] toArray(T[] array)`

最初の書式は引数なしで呼び出せますが、変換後の配列は `Object` クラスの配列になります。`Object` クラスの配列を元のクラスの配列にキャストするのは非常に手間がかかります。

2 番目の書式は引数に出力先の配列を指定して、その配列に要素を格納するものです。引数の配列とコレクションの要素数が一致している場合は、引数の配列に要素が設定されてそのまま戻り値となります。引数の配列の要素数が不足する場合には、`toArray` メソッドが新しい配列を作成して要素を設定し戻り値とします。

コレクション側は、格納している要素のクラスの情報から配列を組み立てることができません。詳細は割愛しますが、`toArray` メソッドは要素型となるクラスの情報だけから配列を生成することができないため、最初の書式では `Object` クラスの配列を返さざるを得なくなっています。`Object` 型の配列にはどのようなクラスのインスタンスでも格納できるため、配列全体をダウンキャストできるとはかぎりません (条件が揃っていればキャスト可能ですが、それを担保する情報はどこにもありません)。

そこで 2 番目の書式でははじめから配列を渡すことで、配列の生成に必要な情報を `toArray` メソッドに伝えているわけです。


なお、`Map` を配列に直接変換する方法は用意されていません。キーと値の割り当て方に合わせて独自に実装する必要があります。

```java
List<String> list = new ArrayList<>();
list.add("Able");
list.add("Baker");
list.add("Charlie");

// List から配列への変換 (1)
String[] array1 = list.toArray(new String[list.size()]);

// List から配列への変換 (2)
// 引数の配列は要素数が少なくても (空の配列であっても) OK
String[] array2 = list.toArray(new String[0]);
```
