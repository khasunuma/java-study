# 10. マルチスレッド

この章では Java が持つ並行処理プログラミングの基礎について示します。C、JavaScript および Visual Basic では並行処理という概念は存在しませんが、Java では言語仕様と標準 API の双方で並行処理を強力にサポートしています。Java が採用している並行処理プログラミングのモデルは「マルチスレッド」と呼ばれているもので、現在のコンピュータ環境では広くサポートされている概念でもあります。

なお、Python では Java 同様にマルチスレッドによる並行処理がサポートされています。C は各 OS に固有のライブラリを使用することで並行処理をサポートします。C++ には標準ライブラリのマルチスレッドサポートを使用する方法と、C 向けのライブラリを使用する方法の 2 通りが用意されていますが、現時点では C 向けのライブラリを使用するケースが多いようです。JavaScript は並行処理をサポートしませんが、擬似的に並行処理を行うライブラリの開発が進められています。これらに対して、Visual Basic は並行処理を全くサポートしません。

Java を学習し始めてしばらくのうちは、並行処理について考慮しなくても大きな問題は発生しません。しかし、Java は実行環境全体で並行処理を活用しているため、本格的にプログラムを記述する場合には並行処理を (それを自発的に使用するか否かに関わらず) 意識する必要があります。始めに並行処理を意識せずにアプリケーションを開発して後から並行処理を考慮した形に作り直す方法もありますが、それよりは初めから並行処理を意識してアプリケーションを開発した方が効率的です。

## 10.1. マルチタスクとマルチスレッド

コンピュータの CPU にかかる負荷は、実際には一様ではありません。複雑な数値演算を行っている場合などは非常に高い負荷で動作していますが、一方で I/O などのリソースへのアクセス時は、リソースからの応答が返ってくるまで基本的にアイドル状態となっています。CPU がアイドル状態となっている時間を別のプログラムの処理に充てることで CPU の稼働率を上げようという発想で生まれたのが「マルチタスク」という考え方です。

マルチタスクは 1960 年代後半から研究が進められていた「タイムシェアリングシステム (TSS)」が生んだ 1 つの成果です。タイムシェアリングシステムは当時同時に 1 人しかコンピュータにアクセスできなかった環境を、複数人で同時にアクセスするための手法として開発されたものです。タイムシェアリングシステムとして最も有名なものは Unix でしょう (Unix は初めてファイルシステムを実用化した OS としても知られています)。Unix が採用したアプローチは、アプリケーションの実行単位を「プロセス」とし、各プロセスに CPU、メモリ、I/O やネットワークなどのリソースを割り当てた上で、OS である Unix がプロセス同士でリソースの競合が起こらないように調停を行うというものです。これは後発の Windows、Linux、Mac OS などにも引き継がれている考え方です。

ここでプロセスに注目すると、実はプロセス自体も CPU にかかる負荷が一様ではないことが分かります。特にプロセスが I/O の応答待ちをしている間、そのプロセスだけに注目するとやはりアイドル状態になっています。そこでプロセスをさらに「スレッド」という単位に分割し、プロセス内部でもリソースを有効活用できる仕組みを作り上げたわけです。最も原始的なプロセスではスレッドは 1 つしか存在しませんが、一定規模のプロセスになると複数のスレッドを活用してリソースを上手く活用するようになります。これを「マルチスレッド」といいます。

プロセスとスレッドを比べると、プロセスは OS から各種リソースを割り当てられ、プロセス間でのリソースの競合については OS が調停を行います。一方でスレッドはプロセスが OS から割り当てられた各種リソースを共用するため、スレッド間でリソース競合対策を行わなければなりません (OS はスレッド内のリソース配分にまで介入しないため)。ここがマルチスレッドの難しいところではあるのですが、コンピュータの性能を最大限発揮するための仕組みとしてマルチスレッドは欠かせない存在となっています。

>なお、Java VM でアプリケーションを実行する際には、アプリケーションを担当する main スレッドが必ず起動しますが、実際にはガベージ・コレクションなどを担当する裏方のスレッドも同時に起動します。無数のシステムでガベージ・コレクションの多発によるアプリケーションの大幅なパフォーマンス低下が発生していますが、これはガベージ・コレクションのスレッドの処理が忙しくなり、main スレッドへのリソース配分が削られる (最悪の場合、ガベージ・コレクション最優先のために main スレッドが一時停止に追い込まれる「Stop the World」が発生する) のが原因です。Java VM のチューニングに問題がある場合も少なくはありませんが、多くの場合はアプリケーションの設計が不適切であることに起因します。

Java では言語仕様と標準 API の双方でマルチスレッドを強力にサポートしています。初期のマルチスレッド・サポートはお世辞にも優れたものとは言えないものでしたが、バージョンを重ねることで使い勝手が大幅に向上しています。

## 10.2. マルチスレッドの基礎

スレッドには以下のような利点があります。

- マルチプロセッサ (マルチコア) を有効活用できる。
- 設計を単純化できる (単一の複雑な処理を、複数の単純な逐次処理に置き換えることができる)。
- 非同期処理イベントの処理を単純化できる (非同期処理を複数の同期処理で置き換えることができる)。
- 応答性の良いユーザーインタフェースを実現できる。

一方で、スレッドは以下のようなリスクも抱えています。

- 同期化が不適切の場合、複数のスレッドの実行順が予測不可能となり、意図しない実行結果となる。
- ハング状態を生むエラーが様々で (デッドロックなど)、かつそれらは開発時や試験時に検出困難である。
- 実行するスレッドが多すぎるとスレッドの管理に CPU リソースを割かれ、逆に実行効率が低下する。

一例として、同期化が不適切な場合を挙げてみましょう。同期化とは、複数のスレッドが同じリソースにアクセスする際の交通整理のようなものです。以下に挙げる `UnsafeSequence` クラスは `getNext` メソッドを呼び出すことで重複のない順序数を取得するクラスです。一見すると正しいプログラムに思えますが、実は大きな落とし穴が潜んでいます。

```java
/**
 * 順序数を返すメソッド getNext を持つクラスです。
 * このクラスはスレッドセーフではありません。
 */
public class UnsafeSequence {

    private int nextValue;
    
    /**
     * 重複のない数を返します。
     * @return 順序数
     */
    public int getNext() {
        return nextValue++;
    }
}
```

仮に `UnsafeSequence.getNext()` メソッドが 2 つのスレッド ThreadA と ThreadB から同時にアクセスされたとしましょう。この時、ThreadA が `UnsafeSequence.getNext()` を呼び出した結果と、ThreadB が `UnsafeSequence.getNext()` を呼び出した結果は、実はわかりません。ThreadA が `0`、ThreadB が `1` をそれぞれ取得する場合もあれば、その逆の場合もあります。さらに ThreadA、ThreadB ともに `0` を取得してしまう場合さえあります。これは `getNext` メソッドが同期化を行っておらず、ThreadA と ThreadB による競合状態を許してしまうからです。その結果、`nextValue` フィールドのインクリメントがプログラマの意図した通りに行われなくなります。

これに対する処方箋は、`getNext` メソッドを同期化することです。メソッドの同期化は、以下に示すように `synchronized` を付加するだけです。

```java
/**
 * 順序数を返すメソッド getNext を持つクラスです。
 * このクラスはスレッドセーフです。
 */
public class Sequence {

    private int nextValue;
    
    /**
     * 重複のない数を返します。
     * @return 順序数
     */
    public synchronized int getNext() {
        return nextValue++;
    }
}
```

上記の同期化を追加したことにより、一方のスレッドが `getNext` を呼び出している間、他のスレッドは待機状態になり、`nextValue` フィールドのインクリメント処理はプログラマの意図した通りに行われるようになります。修正後のクラス `Sequence` のように、複数のスレッドから同時にアクセスされたとき、実行順やタイミングに関わらず、また呼び出し側で特別な配慮をしなくても正しく振る舞う状態を「スレッドセーフ」といいます。

>すべてのクラスがスレッドセーフである必要はありません。スレッドセーフを保つためには相応のコストがかかるためです。例えば、Java Collections Framework ([9 章](chapter09.md) を参照) はスレッドセーフではありません。ただし、Java のクラスやメソッドが複数のスレッドから呼び出される可能性があることだけは常に意識しておく必要があります。そのためにも、ドキュメンテーション・コメント (Javadoc) にそのクラスの同期化に対するポリシー (最低限スレッドセーフか否か) は明示しておきましょう。

さて、先に挙げた `UnsafeSequence` のように、複数のスレッドが同じ可変なフィールドに対して同期化なしでアクセスしている場合、そのプログラムは欠陥プログラムです。それを修正する方法は 3 つあります。

- そのフィールドを複数のスレッドが**共有しないようにする**。
- そのフィールドを**変更不能**にする。
- そのフィールドへのアクセスを常に**同期化**する。

ただし、これらの修正を既存のクラスに対して行うのは決して簡単ではありません。そのため、クラスの設計段階でこれらを念頭に置いて初めからスレッドセーフにしてしまうほうが簡単です。

----

### 【コラム】 Servlet/JSP はマルチスレッドで動作している

サーバーサイド Java の入門でよく用いられている Servlet と JSP (Java Server Pages) ですが、これらが実はマルチスレッドで動作していることにお気づきでしょうか？

Servlet はレスポンスを向上させるためにプロセスではなくスレッドで動作しています。これは、スレッドで定義したフィールドを同期化しなかった場合に意図しない結果が得られる可能性を示唆しています。さらに、Servlet ではブラウザを開いている限り状態を保持するための「セッション・オブジェクト」がサポートされていますが (`HttpSession` のことです)、これも複数のスレッドからアクセスされる可能性があるため、スレッドセーフとなるよう設計しなければなりません。実際のところはスレッドセーフでなくても使用できますが、ある日突然セッション・オブジェクトが破損し原因も分からない、と言った状況になり得ます。

>セッション・オブジェクトにはさらに `Serializable` インタフェースの実装による直列化が事実上義務づけられています。こちらも単一のアプリケーション・サーバー上で動作させる場合に限っては無視しても動作することもありますが、サーバーをクラスタ構成 (冗長化構成) にした段階でセッション・レプリケーションに失敗してアプリケーションが動作しなくなります。

JSP は HTML にコードを埋め込む「PHP スタイル」のコーディングで簡単にサーバーサイド Java アプリケーションを構築可能な技術ではありますが、PHP とは異なり、実行時に同じ処理を行う Servlet に変換する仕組みとなっています。そのため、JSP も最終的には Servlet に変換されマルチスレッドで動作することとなり、上記の問題点がすべてそのまま当てはまることになります。

## Thread クラスを用いたマルチスレッド


## Concurrency Utilities を用いたマルチスレッド


## CompletableFuture を用いたマルチスレッド


